<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Include p5.js library -->
    <script src="p5.js"></script>
<!--    <link rel="stylesheet" type="text/css" href="style.css">-->
    <meta charset="utf-8" />
  </head>
  <body>
  <canvas id="defaultCanvas0" class="p5Canvas" width="1420" height="800" style="width: 710px; height: 400px;"></canvas>
  <button>Click</button>
  <script>

 // 이 변수는 셰이더 객체를 담습니다.
 let theShader;
 // 이 변수는 웹캠 비디오를 담습니다.
 let cam;

 function preload(){
   // 셰이더 불러오기
   theShader = loadShader('assets/webcam.vert', 'assets/webcam.frag');
 }

 function setup() {
  // 셰이더 작동을 위해 WEBGL 모드가 필요합니다.
   createCanvas(710, 400, WEBGL);
   noStroke();

   cam = createCapture(VIDEO);
   cam.size(710, 400);

   cam.hide();
 }

 function draw() {
   // shader()는 활성화 셰이더를 theShader로 설정합니다.
   shader(theShader);

   // cam을 텍스처로 보내기
   theShader.setUniform('tex0', cam);

  // rect()함수로 화면에 기하 추가하기
   rect(0,0,width,height);
 }

       // Filter on devices with the Arduino Uno USB Vendor/Product IDs.
    // const filters = [
    //     {usbVendorId: 0x2341, usbProductId: 0x0043},
    //     {usbVendorId: 0x2341, usbProductId: 0x0001}
    // ];

    // Prompt user to select an Arduino Uno device.
//     document.querySelector('button').addEventListener('click', async () => {
//         // Prompt user to select any serial port.
//         const port = await navigator.serial.requestPort({filters});
//         // console.log(port)
//         await port.open({baudRate: 9600});
//         const {usbProductId, usbVendorId} = port.getInfo();
//         // const reader = port.readable.getReader();
//
//         // Listen to data coming from the serial device.
//         // while (true) {
//         //     const {value, done} = await reader.read();
//         //     if (done) {
//         //         // Allow the serial port to be closed later.
//         //         reader.releaseLock();
//         //         break;
//         //     }
//         //     // value is a Uint8Array.
//         //     console.log(value);
//         // }
//         const textDecoder = new TextDecoderStream();
//         const readableStreamClosed = port.readable.pipeTo(textDecoder.writable);
//         const reader = textDecoder.readable.getReader();
//
// // Listen to data coming from the serial device.
//         while (true) {
//             var {value, done} = await reader.read();
//             if (done) {
//                 // Allow the serial port to be closed later.
//                 reader.releaseLock();
//                 break;
//             }
//             // value is a string.
//             console.log(value);
//             function serialEvent (Serial value) {
//   var data = value.readStringUntil('.');
//   data = data.substring(0,length(data)-1);
//
//   var index1 = data.indexOf(",");
//   var angle= data.substring(0, index1);
//   var distance= data.substring(index1+1, data.length());
//
//   iAngle = int(angle);
//   iDistance = int(distance);
// }
//
//         }
//     });
  </script>
    <script>
  //For Processing 3.2.3- MacOS Sierra
//Author: Niam Moltta
//Jan-2017
// import processing.serial.*; // imports library for serial communication
// import java.awt.event.KeyEvent; // imports library for reading the data from the serial port
// import java.io.IOException;


//String Port = "/dev/tty.usbmodem1411"; //Arduino port
// Serial myPort;

//
// var angle="";
// var distance="";
// var data="";
// var noObject;
// var pixsDistance;
// var iAngle, iDistance;
// var index1=0;
// var index2=0;
// let myFont;
// function preload() {
//   myFont = loadFont('OCRAExtended-30.vlw');
// }
//
//
// function setup() {
//
//  size (1250, 650); //resolution
//  smooth();
//  // myPort = new Serial(this, "COM8", 9600);
//  // myPort.bufferUntil('.');
//   fill('#ED225D');
//   textFont(myFont);
//   textSize(36);
//   text('p5*js', 10, 50);
// }
// function draw() {
//
//   fill(98,245,31);
//   textFont(orcFont);
//   noStroke();
//   fill(0,4);
//   rect(0, 0, width, height-height*0.065);
//
//   fill(98,245,31);
//
//   drawRadar();
//   drawLine();
//   drawObject();
//   drawText();
// }
//
// function drawRadar() {
//
//   pushMatrix();
//   translate(width/2,height-height*0.074);
//   noFill();
//   strokeWeight(2);
//   stroke(98,245,31);
//
//   arc(0,0,(width-width*0.0625),(width-width*0.0625),PI,TWO_PI);
//   arc(0,0,(width-width*0.27),(width-width*0.27),PI,TWO_PI);
//   arc(0,0,(width-width*0.479),(width-width*0.479),PI,TWO_PI);
//   arc(0,0,(width-width*0.687),(width-width*0.687),PI,TWO_PI);
//
//   line(-width/2,0,width/2,0);
//   line(0,0,(-width/2)*cos(radians(30)),(-width/2)*sin(radians(30)));
//   line(0,0,(-width/2)*cos(radians(60)),(-width/2)*sin(radians(60)));
//   line(0,0,(-width/2)*cos(radians(90)),(-width/2)*sin(radians(90)));
//   line(0,0,(-width/2)*cos(radians(120)),(-width/2)*sin(radians(120)));
//   line(0,0,(-width/2)*cos(radians(150)),(-width/2)*sin(radians(150)));
//   line((-width/2)*cos(radians(30)),0,width/2,0);
//   popMatrix();
// }
//
//
// function drawObject() {
//
//   pushMatrix();
//   translate(width/2,height-height*0.074);
//   strokeWeight(9);
//   stroke(255,10,10);
//   pixsDistance = iDistance*((height-height*0.1666)*0.025);
//
//   if(iDistance<40){ //range limit
//
//   line(pixsDistance*cos(radians(iAngle)),-pixsDistance*sin(radians(iAngle)),(width-width*0.505)*cos(radians(iAngle)),-(width-width*0.505)*sin(radians(iAngle)));
//   }
//   popMatrix();
// }
// function drawLine() {
//   pushMatrix();
//   strokeWeight(9);
//   stroke(30,250,60);
//   translate(width/2,height-height*0.074);
//   line(0,0,(height-height*0.12)*cos(radians(iAngle)),-(height-height*0.12)*sin(radians(iAngle)));
//   popMatrix();
// }
//
//
// function drawText() {
//
//   pushMatrix();
//   fill(0,0,0);
//   noStroke();
//   rect(0, height-height*0.0648, width, height);
//   fill(98,245,31);
//   textSize(15);
//   text("10cm",width-width*0.3854,height-height*0.0833);
//   text("20cm",width-width*0.281,height-height*0.0833);
//   text("30cm",width-width*0.177,height-height*0.0833);
//   text("40cm",width-width*0.0729,height-height*0.0833);
//   textSize(30);
//   text("Angle: " + iAngle +" °", width-width*0.48, height-height*0.0277);
//   text("Distance: ", width-width*0.26, height-height*0.0277);
//   if(iDistance<40) {
//   text("        " + iDistance +" cm", width-width*0.225, height-height*0.0277);
//   }
//   textSize(25);
//   fill(98,245,60);
//   translate((width-width*0.4994)+width/2/cos(radians(30)),(height-height*0.0907)-width/2/sin(radians(30)));
//   rotate(-radians(-60));
//   text("30°",0,0);
//   resetMatrix();
//   translate((width-width*0.503)+width/2/cos(radians(60)),(height-height*0.0888)-width/2/sin(radians(60)));
//   rotate(-radians(-30));
//   text("60°",0,0);
//   resetMatrix();
//   translate((width-width*0.507)+width/2/cos(radians(90)),(height-height*0.0833)-width/2/sin(radians(90)));
//   rotate(radians(0));
//   text("90°",0,0);
//   resetMatrix();
//   translate(width-width*0.513+width/2/cos(radians(120)),(height-height*0.07129)-width/2/sin(radians(120)));
//   rotate(radians(-30));
//   text("120°",0,0);
//   resetMatrix();
//   translate((width-width*0.5104)+width/2/cos(radians(150)),(height-height*0.0574)-width/2/sin(radians(150)));
//   rotate(radians(-60));
//   text("150°",0,0);
//   popMatrix();
// }
</script>
  </body>
</html>